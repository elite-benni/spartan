import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';

// Path to the alert.preview.ts file relative to the project root
const PREVIEW_FILE_PATH = 'apps/app/src/app/pages/(components)/components/(alert)/alert.preview.ts';
// Path for the new file that will store the generated code.
const GENERATED_OUTPUT_PATH = 'apps/app/src/app/pages/(components)/components/(alert)/alert.generated.ts';


function extractComponentDetails(filePath: string): {
	componentSource: string;
	imports: string;
	template: string;
	fullOriginalSource: string;
} {
	const absoluteFilePath = path.resolve(filePath);
	const originalSourceText = fs.readFileSync(absoluteFilePath, 'utf-8');

	const sourceFile = ts.createSourceFile(absoluteFilePath, originalSourceText, ts.ScriptTarget.Latest, true);

	let template = '';
	const importStatements: string[] = [];
	let componentSource = '// AlertPreviewComponent source not found';

	sourceFile.statements.forEach((statement) => {
		if (ts.isImportDeclaration(statement)) {
			importStatements.push(statement.getText(sourceFile).trim());
		}
	});

	ts.forEachChild(sourceFile, (node) => {
		if (ts.isClassDeclaration(node) && node.name?.getText(sourceFile) === 'AlertPreviewComponent') {
			componentSource = node.getText(sourceFile); // Get the full text of the class
			const decorators = ts.getDecorators(node);
			decorators?.forEach((decoratorNode) => {
				if (!ts.isDecorator(decoratorNode)) return;
				if (ts.isCallExpression(decoratorNode.expression)) {
					const decoratorIdentifier = decoratorNode.expression.expression;
					if (decoratorIdentifier.getText(sourceFile) === 'Component') {
						const componentMetadata = decoratorNode.expression.arguments[0] as ts.ObjectLiteralExpression;
						componentMetadata.properties.forEach((property) => {
							if (ts.isPropertyAssignment(property) && property.name.getText(sourceFile) === 'template') {
								if (ts.isNoSubstitutionTemplateLiteral(property.initializer)) {
									template = property.initializer.getText(sourceFile).slice(1, -1).trim(); // Remove backticks
								} else if (ts.isStringLiteral(property.initializer)) {
									template = property.initializer.text;
								}
							}
						});
					}
				}
			});
		}
	});

	return {
		componentSource,
		imports: importStatements.join('\n'),
		template,
		fullOriginalSource: originalSourceText,
	};
}

function writeGeneratedFile(
	generatedFilePath: string,
	details: { componentSource: string; imports: string; template: string; fullOriginalSource: string },
	originalPreviewFilePath: string,
) {
	const absoluteGeneratedFilePath = path.resolve(generatedFilePath);

	// For defaultCode: we want the imports used by the component + the component class code.
	// The `details.imports` contains ALL imports from alert.preview.ts.
	// The `details.componentSource` is just the class.
	// The original `defaultCode` was the entire preview component file.
	// Let's stick to the user's definition: "defaultCode is basically the complete code of the preview file"
	// This means the original content of alert.preview.ts before we strip out the const exports.
	// However, the point is to *generate* these, so defaultCode should be based on the component.
	// A good `defaultCode` would be the `AlertPreviewComponent`'s class definition plus its necessary imports.
	// For now, let's use the component class source and all imports from the file.
	// A more advanced version could try to filter imports only used by this specific component.

	const defaultCodeContent = `${details.imports}\n\n${details.componentSource}`;

	const outputContent = `// THIS FILE IS GENERATED BY tools/generators/update-alert-preview-strings.ts
// DO NOT EDIT THIS FILE DIRECTLY

// Original file: ${originalPreviewFilePath}

export const defaultCode = \`
${defaultCodeContent.replace(/`/g, '\\`')}
\`;

export const defaultImports = \`
${details.imports.replace(/`/g, '\\`')}
\`;

export const defaultSkeleton = \`
${details.template.replace(/`/g, '\\`')}
\`;
`;

	fs.writeFileSync(absoluteGeneratedFilePath, outputContent, 'utf-8');
	console.log(`Generated code written to ${absoluteGeneratedFilePath}`);
}

function updateAlertPageTs(alertPageTsPath: string, generatedModulePath: string) {
    const absoluteAlertPageTsPath = path.resolve(alertPageTsPath);
    let content = fs.readFileSync(absoluteAlertPageTsPath, 'utf-8');

    const importLineToRemoveDefaultExports = `import { AlertPreviewComponent, defaultCode, defaultImports, defaultSkeleton } from './alert.preview';`;
    const newImportStatements = `import { AlertPreviewComponent } from './alert.preview';\nimport { defaultCode, defaultImports, defaultSkeleton } from './${path.basename(generatedModulePath, '.ts')}';`;

    if (content.includes(importLineToRemoveDefaultExports)) {
        content = content.replace(importLineToRemoveDefaultExports, newImportStatements);
        fs.writeFileSync(absoluteAlertPageTsPath, content, 'utf-8');
        console.log(`Updated imports in ${alertPageTsPath} (specific line match).`);
    } else {
        // Fallback for slightly different import structures or if AlertPreviewComponent is not grouped with the others.
        const regex = /import\s+\{(.*)\}\s+from\s+'\.\/alert\.preview';/;
        const match = content.match(regex);
        if (match) {
            const allImportsInLine = match[1].split(',').map(s => s.trim());
            const constantsToRemove = ['defaultCode', 'defaultImports', 'defaultSkeleton'];
            const remainingImportsFromPreview = allImportsInLine.filter(imp => !constantsToRemove.includes(imp) && imp.length > 0);

            let updatedImportLineForPreview = '';
            if (remainingImportsFromPreview.length > 0) {
                updatedImportLineForPreview = `import { ${remainingImportsFromPreview.join(', ')} } from './alert.preview';\n`;
            } else {
                // If all imports from './alert.preview' were the constants, this line might be removed by the replace.
                // This is fine if AlertPreviewComponent is not used, or imported separately.
                // However, AlertPreviewComponent is used. So this path should ideally not be hit if the specific line match fails.
            }

            const importLineForGenerated = `import { defaultCode, defaultImports, defaultSkeleton } from './${path.basename(generatedModulePath, '.ts')}';`;

            // Replace the original line with the potentially modified preview import and the new generated import
            content = content.replace(regex, `${updatedImportLineForPreview}${importLineForGenerated}`.trim());
            fs.writeFileSync(absoluteAlertPageTsPath, content, 'utf-8');
            console.log(`Updated imports in ${alertPageTsPath} (regex match).`);
        } else {
            console.warn(`Could not find the import statement for './alert.preview' in ${alertPageTsPath} to update. Manual update might be needed.`);
        }
    }
}

try {
	console.log(`Processing ${PREVIEW_FILE_PATH}...`);
	const details = extractComponentDetails(PREVIEW_FILE_PATH);

	// Instead of modifying alert.preview.ts, we write to a new file alert.generated.ts
	// and then update alert.page.ts to import from this new file.
	writeGeneratedFile(GENERATED_OUTPUT_PATH, details, PREVIEW_FILE_PATH);

	// Remove the old exported consts from alert.preview.ts
	const absolutePreviewFilePath = path.resolve(PREVIEW_FILE_PATH);
	let previewFileContent = fs.readFileSync(absolutePreviewFilePath, 'utf-8');
	previewFileContent = previewFileContent.replace(/export const defaultCode = `[\s\S]*?`;\s*/, '');
	previewFileContent = previewFileContent.replace(/export const defaultImports = `[\s\S]*?`;\s*/, '');
	previewFileContent = previewFileContent.replace(/export const defaultSkeleton = `[\s\S]*?`;\s*/, '');
	fs.writeFileSync(absolutePreviewFilePath, previewFileContent.trim() + '\n', 'utf-8');
	console.log(`Cleaned up exported constants from ${PREVIEW_FILE_PATH}`);

	// Update alert.page.ts to use the new generated file
	const alertPageTsPath = 'apps/app/src/app/pages/(components)/components/(alert)/alert.page.ts';
	updateAlertPageTs(alertPageTsPath, GENERATED_OUTPUT_PATH);

	console.log('Alert code generation process complete.');
	console.log(`\nNext steps:
1. Add a script to your package.json to run this generator, e.g.,
   "generate:alert-preview": "npx ts-node tools/generators/update-alert-preview-strings.ts"
2. Run the script (npm run generate:alert-preview or yarn generate:alert-preview).
3. Commit the changes to:
   - ${PREVIEW_FILE_PATH} (old constants removed)
   - ${GENERATED_OUTPUT_PATH} (new generated file)
   - ${alertPageTsPath} (imports updated)
   - tools/generators/update-alert-preview-strings.ts (the generator script itself)
`);

} catch (error) {
	console.error('Error during code generation:', error);
}
