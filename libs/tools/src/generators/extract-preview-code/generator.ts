import { Tree, formatFiles, joinPathFragments, logger } from '@nx/devkit';
import ts from 'typescript';

// Define the schema interface, even if it's empty for now
export interface ExtractPrimitiveCodeGeneratorSchema {
	// Currently no options, but good practice to have it defined
	projectName?: string; // Optional: specify a project, otherwise scan apps
}

function getSourceFile(tree: Tree, filePath: string): ts.SourceFile | undefined {
	const content = tree.read(filePath, 'utf-8');
	if (!content) {
		logger.warn(`File not found or empty: ${filePath}`);
		return undefined;
	}

	const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true);
	return sourceFile;
}

function removeDefaultCodesAndGetContent(sourceFile: ts.SourceFile) {
	let content = '';
	ts.forEachChild(sourceFile, (node) => {
		const nodeText = node.getFullText(sourceFile).trim();
		if (
			nodeText.includes('export const defaultCode =') ||
			nodeText.includes('export const defaultSkeleton =') ||
			nodeText.includes('export const defaultImports =')
		) {
			logger.info(`Removing default code: ${nodeText}`);
			return;
		}
		logger.info(`Keeping code: ${nodeText}`);

		content += nodeText;
	});
	return content;
}

export async function extractPrimitiveCodeGenerator(tree: Tree, _schema: ExtractPrimitiveCodeGeneratorSchema) {
	logger.info('Extract Primitive Code generator running...');

	const componentsDir = 'apps/app/src/app/pages/(components)/components';

	// Check if the base directory exists
	if (!tree.exists(componentsDir)) {
		logger.warn(`Base components directory not found: ${componentsDir}. Nothing to do.`);
		return;
	}

	const componentDirs = tree.children(componentsDir);

	for (const primitiveName of componentDirs) {
		const primitiveDir = joinPathFragments(componentsDir, primitiveName);
		if (tree.isFile(primitiveDir)) {
			logger.info(`Skipping ${primitiveDir} as it is not a directory.`);
			continue;
		}

		// strip () from primitiveName
		const primitiveNameWithoutParentheses = primitiveName.replaceAll('(', '').replaceAll(')', '');

		logger.info(`Processing primitive -->: ${primitiveNameWithoutParentheses}`);

		const previewFilePath = joinPathFragments(primitiveDir, `${primitiveNameWithoutParentheses}.preview.ts`);

		if (!tree.exists(previewFilePath)) {
			logger.warn(`Preview file not found for primitive ${primitiveNameWithoutParentheses}: ${previewFilePath}`);
			continue;
		}

		const previewSourceFile = getSourceFile(tree, previewFilePath);
		if (!previewSourceFile) {
			logger.warn(`Could not find source file for ${previewFilePath}`);
			continue; // Already logged by getSourceFile
		}

		const defaultCode = removeDefaultCodesAndGetContent(previewSourceFile);

		// Assuming the component in preview.ts is named like 'AlertPreviewComponent' -> primitiveName capitalized + PreviewComponent
		const previewComponentClassName =
			primitiveNameWithoutParentheses.charAt(0).toUpperCase() +
			primitiveNameWithoutParentheses.slice(1) +
			'PreviewComponent';

		logger.info(`Extracted template for ${previewComponentClassName} in ${previewFilePath}`);
		const generatedFilePath = joinPathFragments(primitiveDir, `${primitiveNameWithoutParentheses}.generated.ts`);
		const generatedFileContent = `// eslint-disable -- auto-generated
// @ts-nocheck -- auto-generated
// prettier-ignore -- auto-generated
/*
DO NOT EDIT THIS FILE!!
It is automatically generated by the extract-primitive-code generator.
Instead, edit the \`${primitiveName}.preview.ts\` file or the generator itself.
*/
export const defaultCode = \`\n${defaultCode.replace(/`/g, '\\`')}\n\`;
`;

		tree.write(generatedFilePath, generatedFileContent);
		logger.info(`Generated ${generatedFilePath}`);
	}

	await formatFiles(tree);

	return () => {
		logger.info('Extract Primitive Code generator finished.');
		logger.info(
			`IMPORTANT: Ensure that your page.ts files (e.g., ${componentDirs[0]}/${componentDirs[0]}.page.ts) are updated to import these variables from the new .generated.ts files.`,
		);
	};
}

export default extractPrimitiveCodeGenerator;
